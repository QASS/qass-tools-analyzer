

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qass.tools.analyzer.buffer_parser &mdash; Qass Tools Analyzer 2.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=9edc463e" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=f35be339"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            Qass Tools Analyzer
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Reading Buffer files</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_parser.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_parser.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_parser.html#buffer">Buffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_parser.html#filter-buffers">Filter buffers</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Cache and Search Metadata</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_metadata_cache.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_metadata_cache.html#example">Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_metadata_cache.html#buffermetadatacache">BufferMetadataCache</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../buffer_metadata_cache.html#buffermetadata">BufferMetadata</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Testing</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../testing.html">MockBuffer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Changelog</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../changelog.html#id1">2.2</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">Qass Tools Analyzer</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">qass.tools.analyzer.buffer_parser</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for qass.tools.analyzer.buffer_parser</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright (c) 2022 QASS GmbH.</span>
<span class="c1"># Website: https://qass.net</span>
<span class="c1"># Contact: QASS GmbH &lt;info@qass.net&gt;</span>
<span class="c1">#</span>
<span class="c1"># This file is part of Qass tools </span>
<span class="c1">#</span>
<span class="c1"># This program is free software: you can redistribute it and/or modify</span>
<span class="c1"># it under the terms of the GNU Lesser General Public License as published by</span>
<span class="c1"># the Free Software Foundation, version 3 of the License.</span>
<span class="c1">#</span>
<span class="c1"># This program is distributed in the hope that it will be useful,</span>
<span class="c1"># but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="c1"># MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="c1"># GNU Lesser General Public License for more details.</span>
<span class="c1">#</span>
<span class="c1"># You should have received a copy of the GNU Lesser General Public License</span>
<span class="c1"># along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="c1">#</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">logging</span><span class="w"> </span><span class="kn">import</span> <span class="n">warning</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">os</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntEnum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">struct</span><span class="w"> </span><span class="kn">import</span> <span class="n">unpack</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">codecs</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">hashlib</span>


<span class="k">class</span><span class="w"> </span><span class="nc">InvalidArgumentError</span><span class="p">(</span><span class="ne">ValueError</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">InvalidFileError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">HeaderDtype</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
    <span class="c1"># Enum helper class to mark data types</span>
    <span class="n">INT32</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">INT64</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">UINT32</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">UINT64</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FLOAT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">DOUBLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">HEX_STRING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<div class="viewcode-block" id="Buffer">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Buffer</span><span class="p">:</span>
<div class="viewcode-block" id="Buffer.DATAMODE">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.DATAMODE">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DATAMODE</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
        <span class="n">DATAMODE_UNDEF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="c1"># Es wird nur ein Zähler übertragen, der im DSP Modul generiert wird</span>
        <span class="n">DATAMODE_COUNTER_UNUSED</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">DATAMODE_SIGNAL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Es werden die reinen Signaldaten gemessen und übertragen</span>
        <span class="c1"># Die FFT wird in der Hardware durchgeführt und das Ergebnis als FFT Daten übertragen</span>
        <span class="n">DATAMODE_FFT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">DATAMODE_PLOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># 2 dimensionale Graph Daten (war INTERLEAVED, das wird nicht mehr genutzt, taucht aber im kernelmodul als Define für DATAMODES noch auf</span>
        <span class="c1"># Datenmodus, der nur in importierten oder künstlichen Buffern auftritt</span>
        <span class="n">DATAMODE_OTHER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># Datamode is video (This means file is not a normal buffer, but simply a video file)</span>
        <span class="n">DATAMODE_VIDEO</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

        <span class="n">DATAMODE_COUNT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>


<div class="viewcode-block" id="Buffer.DATATYPE">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.DATATYPE">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DATATYPE</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>  <span class="c1"># Kompressionsmethoden oder auch Buffertypen</span>
        <span class="n">COMP_INVALID</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span>
        <span class="n">COMP_UNDEF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">COMP_RAW</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Die reinen unkomprimierten Rohdaten, sowie sie aus der Hardware kommen</span>
        <span class="c1"># Datenreduktion durch einfaches Downsampling (jedes x-te Sample gelangt in den Buffer)</span>
        <span class="n">COMP_DOWNSAMPLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_MAXIMUM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Die Maximalwerte von jeweils x Samples gelangen in den Buffer</span>
        <span class="c1"># Die Durchschnittswerte über jeweils x Samples gelangen in den Buffer</span>
        <span class="n">COMP_AVERAGE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_STD_DEVIATION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Die Standardabweichung</span>
        <span class="n">COMP_ENVELOP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># NOT USED!! Der Buffer stellt eine Hüllkurve dar</span>
        <span class="n">COMP_MOV_AVERAGE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Der gleitende Mittelwert über eine Blockgröße von x Samples</span>
        <span class="c1"># Die Bufferdaten wurden aus einer externen Quelle, die nicht mit dem Optimizer aufgezeichnet wurden erstellt</span>
        <span class="n">COMP_EXTERN_DATA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># Zur Zeit verwendet, um MinMaxObjekt Energy signature buffer zu taggen</span>
        <span class="n">COMP_ANALYZE_OVERVIEW</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># Der gleitende Mittelwert über eine Blockgröße von x Samples (optimierte Berechnung)</span>
        <span class="n">COMP_MOV_AVERAGE_OPT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_COLLECTION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Wild zusammengeworfene Datenmasse</span>
        <span class="n">COMP_IMPORT_SIG</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Importierte Signaldaten</span>
        <span class="n">COMP_SCOPE_RAW</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Vom Oszilloskop aufgezeichnet</span>
        <span class="c1"># Der gleitende Mittelwert (Zeit und Frequenz) über eine Blockgröße von x Samples</span>
        <span class="n">COMP_MOV_AVERAGE_FRQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_SLOPECHANGE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Steigungswechsel der Amplituden über die Zeit</span>
        <span class="n">COMP_OTHER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_IO_SIGNAL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Aufgezeichnete IO Signale</span>
        <span class="n">COMP_ENERGY</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Die Energie (in erster Linie für DM=ANALOG)</span>
        <span class="n">COMP_AUDIO_RAW</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Raw Daten, die mit dem Sound Device aufgezeichnet wurden</span>
        <span class="c1"># was COMP_OBJECT before. Now it is used for Datamode PLOT. Type will be displayed as Graphname, if set</span>
        <span class="n">COMP_XY_PLOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_SECOND_FFT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># Raw Daten vom Audio Device, bei denen es sich um einen Audiokommentar handelt</span>
        <span class="n">COMP_AUDIO_COMMENT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># CrackProperties Energy Signatur, kommt in erster Linie von Energieprofilen, die auf Daten der CrackDefinitionen Berechnet wurden</span>
        <span class="n">COMP_CP_ENERGY_SIG</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># This is a video stream that has been recorded while measuring</span>
        <span class="n">COMP_VID_MEASURE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># This is a screen cast video stream, that has been captured while measuring or session recording</span>
        <span class="n">COMP_VID_SCREEN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_VID_EXT_LINK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># This is an extern linked video file</span>
        <span class="n">COMP_ENVELOPE_UPPER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># NOT_USED!! Obere Hüllfläche</span>
        <span class="n">COMP_ENVELOPE_LOWER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># NOT_USED! Untere Hüllfläche</span>
        <span class="n">COMP_PATTERN_REFOBJ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># NOT USED! A Pattern Recognition reference object</span>
        <span class="n">COMP_SIGNIFICANCE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Nur starke Änderungen werden aufgezeichnet</span>
        <span class="c1"># this is the signed 32 bit version of a significance buffer</span>
        <span class="n">COMP_SIGNIFICANCE_32</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># NOT_USED! A mask buffer for a pattern ref object (likely this is a float buffer)</span>
        <span class="n">COMP_PATTERN_MASK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">COMP_GRADIENT_FRQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Gradient buffer in frequency direction</span>
        <span class="c1"># Not realy a datatype but used to create CSV files from source buffer</span>
        <span class="n">COMP_CSV_EXPORT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># Die Anzahl der Einträge in der Datatypesliste, kein wirklicher Datentyp</span>
        <span class="n">COMP_COUNT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>


<div class="viewcode-block" id="Buffer.DATAKIND">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.DATAKIND">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">DATAKIND</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>  <span class="c1"># Zusätzliche Spezifikation des Buffers</span>
        <span class="n">KIND_UNDEF</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">KIND_NONE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">KIND_SENSOR_TEST</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Sensor Pulse Test Daten</span>
        <span class="c1"># Debug Plot Buffer, der die Zeiten für das &quot;freimachen&quot; eines Datenblocks enthält</span>
        <span class="n">KIND_PLOT_FREE_DATABLOCK_TIMING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">KIND_PATTERN_REF_OBJ_COMPR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">KIND_PATTERN_REF_OBJ_MASK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">KIND_PATTERN_REF_OBJ_EXTRA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">KIND_FREE_6</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">KIND_FREE_7</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">DATAKIND_CNT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="c1"># This datakind is out ouf range. It cannot be stored in bufferId anymore (this is legacy stuff)</span>
        <span class="n">KIND_CAN_NOT_BE_HANDLED</span> <span class="o">=</span> <span class="n">DATAKIND_CNT</span>

        <span class="c1"># Werte ab hier zur freien Verwendung (Oft ist das ein Zähler für verschiedene Buffer, die ansonsten den selben FingerPrint hätten)</span>
        <span class="n">KIND_USER</span> <span class="o">=</span> <span class="mi">100</span></div>


<div class="viewcode-block" id="Buffer.ADCTYPE">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.ADCTYPE">[docs]</a>
    <span class="k">class</span><span class="w"> </span><span class="nc">ADCTYPE</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
        <span class="n">ADC_NOT_USED</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ADC_LEGACY_14BIT</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ADC_16BIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
        <span class="n">ADC_24BIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filepath</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__filepath</span> <span class="o">=</span> <span class="n">filepath</span>
        <span class="c1"># uint: read with np.uintc and then cast to python int</span>
        <span class="c1"># c double is python float</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">uintc</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;qassdata----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;filevers----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;datavers----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;savefrom----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;datamode----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;datatype----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;datakind----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;framsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;smplsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;frqbands----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;db_words----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;avgtimba----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;avgfrqba----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;m_u_mask--------&quot;</span><span class="p">,</span><span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;b_p_samp----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;s_p_fram----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;db__size----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;max_ampl----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;nul_ampl----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;samplert----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;datarate--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;samplefr----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;frqshift----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fftovers----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;fftlogsh----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;fftwinfu----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;dbhdsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;comratio----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;tc__real--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;frqratio----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;fc__real--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;proj__id--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;file__id--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;parentid--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;proc_cnt----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;proc_rng----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;proc_sub----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;poly_cnt----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;polycyid----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;dumpchan----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;del_lock----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;proctime----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;lmodtime----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;epoctime--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;mux_port----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pampgain----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;dispgain----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;linfgain----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;auxpara0----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;auxpara1----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;auxpara2----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;auxpara3----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;auxpara4----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;auxpara5--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;skipsamp--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;skiptime--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;trunsamp--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;truntime--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;skiplfrq----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;trunhfrq----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;startfrq----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;end__frq----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;frqpband--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;framedur--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;frameoff----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;p__flags----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;realfrqc----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sub_data----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sd_dimen----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sd_rsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sd_rsizf--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sd_dsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;frqmasks----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;frqinmas----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;eheaderf----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;adc_type----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;adbitres----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;baserate--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;interpol----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;dcoffset----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;dispralo----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;disprahi----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;rngtibeg--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;rngtiend--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;realsoff--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;extendid--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sim_mode----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;partnoid----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;asc_part----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;asc_desc----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;comments----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sparemem----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;streamno----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;an4dvers----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">HEX_STRING</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;headsend&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__db_keywords</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s2">&quot;blochead----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;firstsam--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;lastsamp--------&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;dbfilled----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;mux_port----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;pampgain----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;dispgain----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;io_ports----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;dversion----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sine_frq----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sine_amp----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sd_dimen----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;sd_rsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;sd_dsize----&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;begin_subdat&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;end___subdat&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">),</span>
            <span class="p">(</span><span class="s2">&quot;blockend&quot;</span><span class="p">,</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">)</span>  <span class="c1"># datatypes for last three keywords guessed</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__db_headers</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__last_spectrum</span><span class="o">=</span><span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__filepath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_header</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_val</span><span class="p">,</span> <span class="n">exc_tb</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return path to buffer file, since this is everything needed to reconstruct a buffer object.</span>
<span class="sd">        This function is needed for pickling buffer objects.</span>

<span class="sd">        :return: Single-element tuple containing the path to the buffer file.</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__filepath</span><span class="p">,</span> <span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reconstruct buffer from state, which only contains the path to the buffer file.</span>
<span class="sd">        This function is needed for unpickling buffer objects.</span>

<span class="sd">        :param state: Single-element tuple containing the path to the buffer file.</span>
<span class="sd">        :type state: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_var_chars</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;asc_desc&#39;</span><span class="p">,</span> <span class="s1">&#39;comments&#39;</span><span class="p">,</span> <span class="s1">&#39;sparemem&#39;</span><span class="p">,</span> <span class="s1">&#39;asc_part&#39;</span><span class="p">]:</span>
            <span class="n">d_len</span> <span class="o">=</span> <span class="n">val</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="n">d_len</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">d_len</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;begin_subdat&quot;</span><span class="p">:</span>
            <span class="n">end_idx</span> <span class="o">=</span> <span class="n">content</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;end___subdat&quot;</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">end_idx</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">end_idx</span>

        <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">idx</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_keyword_ascii</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">95</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">122</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;=</span> <span class="mi">48</span> <span class="ow">and</span> <span class="n">c</span> <span class="o">&lt;=</span> <span class="mi">57</span><span class="p">)</span>

<span class="w">    </span><span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Test if given bytearray could be a valid keyword</span>
<span class="sd">    Input: bytes testkey</span>
<span class="sd">    Return: returns True, if all characters are lower case ASCII or numbers or _</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_possible_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">testkey</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">testkey</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_keyword_ascii</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_header_val</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">keyword</span><span class="p">):</span>
        <span class="n">key</span><span class="p">:</span> <span class="nb">str</span>
        <span class="n">key</span><span class="p">,</span> <span class="n">data_type</span> <span class="o">=</span> <span class="n">keyword</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">)</span>
        <span class="n">data_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">keyword</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="n">data_type</span> <span class="o">=</span> <span class="n">keyword</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">curr_content</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span><span class="n">idx</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span>

        <span class="c1"># TODO: fill the if structur with the correct unpack method from struct.unpack</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">__read_from_bytes</span><span class="p">(</span><span class="n">data_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Method to translate byte data into correct python datatypes, with the help of given data type</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">val</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT32</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">INT64</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;q&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT32</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">UINT64</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;Q&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">DOUBLE</span><span class="p">:</span>
                <span class="n">val</span><span class="p">,</span> <span class="o">=</span> <span class="n">unpack</span><span class="p">(</span><span class="s2">&quot;d&quot;</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="n">HeaderDtype</span><span class="o">.</span><span class="n">HEX_STRING</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">codecs</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span> <span class="s2">&quot;hex&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">data_type</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">bytes</span>

            <span class="k">return</span> <span class="n">val</span>

        <span class="k">if</span> <span class="n">curr_content</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span> <span class="o">==</span> <span class="n">key</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">data_len</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">__read_from_bytes</span><span class="p">(</span>
                    <span class="n">data_type</span><span class="p">,</span> <span class="n">content</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span> <span class="n">idx</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">])</span>
                <span class="c1">#val = int.from_bytes(content[idx: idx + data_len], byteorder=&#39;little&#39;, signed=True)</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="n">data_len</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_var_chars</span><span class="p">(</span><span class="n">content</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_read_next_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">keywords</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">keyword</span> <span class="ow">in</span> <span class="n">keywords</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_header_val</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">keyword</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
                <span class="c1">#key, val, next_idx = res</span>
                <span class="k">return</span> <span class="n">res</span>
        <span class="c1"># keyword not found</span>
        <span class="n">current_key</span> <span class="o">=</span> <span class="n">content</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span> <span class="n">idx</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Error: Key word &quot;</span><span class="si">{</span><span class="n">current_key</span><span class="si">}</span><span class="s1">&quot; not supported by buffer_parser&#39;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># this should contain the complete header i sugest...</span>
        <span class="n">header_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="mi">4096</span><span class="p">)</span>
        <span class="n">magic_bytes</span> <span class="o">=</span> <span class="n">header_arr</span><span class="p">[:</span><span class="mi">8</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">magic_bytes</span> <span class="o">!=</span> <span class="sa">b</span><span class="s2">&quot;qassdata&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidFileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a valid data stream file&quot;</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">header_size</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_header_val</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">header_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__keywords</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">header_arr</span> <span class="o">=</span> <span class="n">header_arr</span><span class="p">[:</span><span class="n">header_size</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">sha256</span><span class="p">()</span>
        <span class="n">m</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">header_arr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__header_hash</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">header_size</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_value</span><span class="p">(</span>
                    <span class="n">idx</span><span class="p">,</span> <span class="n">header_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__keywords</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">+=</span> <span class="mi">12</span>  <span class="c1"># skip unknown parameter value</span>
                <span class="n">testkey</span> <span class="o">=</span> <span class="n">header_arr</span><span class="p">[</span><span class="n">idx</span><span class="p">:</span> <span class="n">idx</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
                <span class="c1"># check if current position contains a possible keyword, otherwise</span>
                <span class="c1"># add 4 to idx, because most likely the unknown keyword has a 64bit value</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_possible_keyword</span><span class="p">(</span><span class="n">testkey</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">+=</span> <span class="mi">4</span>

            <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_END</span><span class="p">)</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file_size</span> <span class="o">=</span> <span class="n">size</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span> <span class="o">=</span> <span class="n">header_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;dbhdsize&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;b_p_samp&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;b_p_samp&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="k">else</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;db__size&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;frqbands&quot;</span><span class="p">,</span> <span class="s2">&quot;s_p_fram&quot;</span><span class="p">,</span> <span class="s2">&quot;framsize&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Failed to determine the frq_bands of the buffer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__db_count</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_calc_spec_duration</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_signalNormalizationFactor</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ad_bit_resolution</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_delog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data_arr</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delog</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ad_bit_resolution</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">,</span> <span class="n">frq_bands</span><span class="p">,</span> <span class="n">conversion</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">pos_start</span> <span class="o">=</span> <span class="n">specFrom</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span>
        <span class="n">pos_end</span> <span class="o">=</span> <span class="n">specTo</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span>

        <span class="n">db_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pos_start</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span><span class="p">)</span>
        <span class="n">db_end</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">pos_end</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span><span class="p">)</span>

        <span class="c1"># The following if clauses check whether the datatype is 2 or 4 bytes long. In case of 4 bytes</span>
        <span class="c1"># it checks whether bit 3 is set in p__flags because bit 3 indicates a float buffer.</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint16</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;p__flags&#39;</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">uint32</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown value for bytes_per_sample&quot;</span><span class="p">)</span>

        <span class="n">np_arrays</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">db</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">db_start</span><span class="p">,</span> <span class="n">db_end</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">db</span> <span class="o">==</span> <span class="n">db_start</span><span class="p">:</span>
                <span class="n">start_in_db</span> <span class="o">=</span> <span class="n">pos_start</span> <span class="o">-</span> <span class="n">db_start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start_in_db</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="n">db</span> <span class="o">==</span> <span class="n">db_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">end_in_db</span> <span class="o">=</span> <span class="n">pos_end</span> <span class="o">-</span> <span class="p">(</span><span class="n">db_end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_in_db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span>

            <span class="n">block_start_pos_in_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span> <span class="o">+</span> <span class="n">db</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">)</span>

            <span class="n">start_pos_in_file</span> <span class="o">=</span> <span class="n">block_start_pos_in_file</span> <span class="o">+</span> <span class="n">start_in_db</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span>
            <span class="n">read_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="n">end_in_db</span> <span class="o">-</span> <span class="n">start_in_db</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">start_pos_in_file</span> <span class="o">+</span> <span class="n">read_len</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The given indices exceed the buffer file&#39;s size.&quot;</span><span class="p">)</span>

            <span class="c1"># TODO: We should check the length of actual data in this datablock - especially for the last data block</span>
            <span class="c1"># but maybe also for intermediate data blocks - since we do not know if the measuring has been paused</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">start_pos_in_file</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>  <span class="c1"># seek</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">read_len</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">conversion</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">conversion</span> <span class="o">==</span> <span class="s1">&#39;delog&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">delog</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_resolution</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">conversion</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_log_shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bit_resolution</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="s2">&quot;The given conversion is unknown&quot;</span><span class="p">)</span>
            <span class="n">np_arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">np_arrays</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span><span class="p">)</span> <span class="c1">#&amp; 0x3fff</span>

<div class="viewcode-block" id="Buffer.get_data">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.get_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specFrom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">specTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">conversion</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function provides access to the measurement data in the buffer</span>
<span class="sd">        file. The data are retrieved for the range of spectra and stored in a</span>
<span class="sd">        numpy array. The data can be logarithmized or not. The datatype of the</span>
<span class="sd">        array depends on the type of buffer.</span>

<span class="sd">        :param specFrom: First spectrum to be retrieved (default first available spectrum)</span>
<span class="sd">        :type specFrom: int, optional</span>
<span class="sd">        :param specTo: Last spectrum to be retrieved (default last available spectrum)</span>
<span class="sd">        :type specTo: int, optional</span>
<span class="sd">        :param conversion: Conversion (&#39;log&#39; or &#39;delog&#39;) of the data.</span>
<span class="sd">        :type conversion: string, optional</span>

<span class="sd">        :raises InvalidArgumentError: The specFrom value is out of range</span>
<span class="sd">        :raises InvalidArgumentError: The specTo value is out of range</span>
<span class="sd">        :raises InvalidArgumentError: specTo or specFrom is not of type int or None</span>
<span class="sd">        :raises ValueError: The given indices exceed the buffer file&#39;s size</span>
<span class="sd">        :raises InvalidArgumentError: The given conversion is unknown</span>

<span class="sd">        :return: The buffers data.</span>
<span class="sd">        :rtype: numpy ndarray</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                import qass.tools.analyzer.buffer_parser as bp</span>
<span class="sd">                proc = range(1,100,1)</span>
<span class="sd">                # path contains the path to a directory containing buffer files</span>
<span class="sd">                buff = bp.filter_buffers(path, {&#39;wanted_process&#39;: proc , &#39;datamode&#39;: bp.Buffer.DATAMODE.DATAMODE_FFT})</span>
<span class="sd">                for buffer in buff:</span>
<span class="sd">                    buff_file = (buffer.filepath)</span>

<span class="sd">                with bp.Buffer(buff_file) as buff:</span>
<span class="sd">                    spec_start = 0</span>
<span class="sd">                    spec_end = (buff.db_count -1) * buff.db_spec_count</span>
<span class="sd">                    print(&#39;Spec_end: &#39; + str(spec_end))</span>
<span class="sd">                    conv = &#39;delog&#39;</span>
<span class="sd">                    data = buff.get_data(spec_start, spec_end, conv)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">specFrom</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">specFrom</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">specFrom</span>
        <span class="n">specTo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span> <span class="k">if</span> <span class="n">specTo</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">specTo</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">specTo</span><span class="p">,</span> <span class="nb">int</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="s2">&quot;specFrom/specTo must be int or None!&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specFrom</span> <span class="o">&gt;</span> <span class="n">specTo</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;specFrom </span><span class="si">{</span><span class="n">specFrom</span><span class="si">}</span><span class="s1"> cannot be larger than specTo </span><span class="si">{</span><span class="n">specTo</span><span class="si">}</span><span class="s1">!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specTo</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">specTo</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;specTo </span><span class="si">{</span><span class="n">specTo</span><span class="si">}</span><span class="s1"> is out of range (0, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="si">}</span><span class="s1">)!&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">specFrom</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">specFrom</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;specFrom </span><span class="si">{</span><span class="n">specFrom</span><span class="si">}</span><span class="s1"> is out of range (0, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="si">}</span><span class="s1">)!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datamode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATAMODE</span><span class="o">.</span><span class="n">DATAMODE_SIGNAL</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">conversion</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span><span class="p">,</span> <span class="n">conversion</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buffer.getArray">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.getArray">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getArray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">specFrom</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">specTo</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delog</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function to &#39;get_data&#39;.</span>
<span class="sd">        This function provides access to the measurement data in the buffer</span>
<span class="sd">        file. The data are retrieved for the range of spectra and stored in a</span>
<span class="sd">        numpy array. The data can be logarithmized or not. The datatype of the</span>
<span class="sd">        array depends on the type of buffer.</span>

<span class="sd">        :param specFrom: First spectrum to be retrieved (default first available spectrum).</span>
<span class="sd">        :type specFrom: int, optional</span>
<span class="sd">        :param specTo: Last spectrum to be retrieved (default last available spectrum).</span>
<span class="sd">        :type specTo: int, optional</span>
<span class="sd">        :param delog: To de-logarithmize the data (default None).</span>
<span class="sd">        :type delog: boolean, optional</span>

<span class="sd">        :raise InvalidArgumentError: The specFrom value is out of range.</span>
<span class="sd">        :raise InvalidArgumentError: The specTo value is out of range.</span>

<span class="sd">        :return: The buffers data.</span>
<span class="sd">        :rtype: numpy ndarray</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                import qass.tools.analyzer.buffer_parser as bp</span>
<span class="sd">                proc = range(1,100,1)</span>
<span class="sd">                # path contains the path to a directory containing buffer files</span>
<span class="sd">                buff = bp.filter_buffers(path, {&#39;wanted_process&#39;: proc , &#39;datamode&#39;: bp.Buffer.DATAMODE.DATAMODE_FFT})</span>
<span class="sd">                for buffer in buff:</span>
<span class="sd">                    buff_file = (buffer.filepath)</span>
<span class="sd">                </span>
<span class="sd">                with bp.Buffer(buff_file) as buff:</span>
<span class="sd">                    spec_start = 0</span>
<span class="sd">                    spec_end = (buff.db_count -1) * buff.db_spec_count</span>
<span class="sd">                    print(&#39;Spec_end: &#39; + str(spec_end))</span>
<span class="sd">                    data = buff.get_array(spec_start, spec_end, True)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">delog</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="s2">&quot;delog&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">delog</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="s2">&quot;log&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_data</span><span class="p">(</span><span class="n">specFrom</span><span class="p">,</span> <span class="n">specTo</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buffer.getSpecDuration">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.getSpecDuration">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getSpecDuration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper Function for property spec_duration.</span>

<span class="sd">        .. seealso: Property spec_duration</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_db_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">content</span><span class="p">:</span> <span class="nb">bytearray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
        <span class="n">db_metainfo</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">content</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;empty header content&#39;</span><span class="p">)</span>
            <span class="c1">#raise ValueError(&#39;empty header content&#39;)</span>
            <span class="k">return</span> <span class="n">db_metainfo</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">read_res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_value</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_keywords</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">read_res</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># key not found</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;header parse error&#39;</span><span class="p">)</span>
                    <span class="n">idx</span><span class="o">+=</span><span class="mi">4</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">read_res</span>
                    <span class="k">if</span> <span class="n">key</span><span class="p">:</span>
                        <span class="n">db_metainfo</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;data block header content not parseble&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">db_metainfo</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_datablock_start_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span> <span class="o">+</span> <span class="n">db_idx</span> <span class="o">*</span> \
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_first_sample_of_datablock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">db_idx</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span><span class="p">)</span>
    
    <span class="k">def</span><span class="w"> </span><span class="nf">_first_spec_of_datablock</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_sample_of_datablock</span><span class="p">(</span><span class="n">db_idx</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span><span class="p">)</span>
    
<div class="viewcode-block" id="Buffer.db_header">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.db_header">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data block header contains key words and their corresponding</span>
<span class="sd">        values. This information is retrieved and stored in a dictionary. The</span>
<span class="sd">        values can be accessed by providing the corresponding key. Please</span>
<span class="sd">        ensure that the key exists in the database prior to its use or</span>
<span class="sd">        use the get method to access its content.Otherwise this will</span>
<span class="sd">        cause a runtime error.</span>


<span class="sd">        :param db_idx: data block index</span>
<span class="sd">        :type db_idx: int</span>

<span class="sd">        :raises Value_Error: The data block index is out of range.</span>

<span class="sd">        :return: a dictionary with the keywords and values</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        .. code block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                # The index of the first data block is 0</span>
<span class="sd">                db_idx = 0</span>
<span class="sd">                # Function to retrieve the size of the data block</span>
<span class="sd">                def db_size(db_idx):</span>
<span class="sd">                    db_header_dict = db_header(0)</span>
<span class="sd">                    return(db_header_dict.get(&#39;dbfilled&#39;, 0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">db_idx</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_count</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;db_idx is out of bounds&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">db_idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_headers</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_headers</span><span class="p">[</span><span class="n">db_idx</span><span class="p">]</span>

        <span class="n">header_start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_datablock_start_pos</span><span class="p">(</span><span class="n">db_idx</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">header_start_pos</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
        <span class="n">db_header_content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">)</span>
        <span class="n">db_metainfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_db_header</span><span class="p">(</span><span class="n">db_header_content</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__db_headers</span><span class="p">[</span><span class="n">db_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">db_metainfo</span>
        <span class="k">return</span> <span class="n">db_metainfo</span></div>


<div class="viewcode-block" id="Buffer.db_header_spec">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.db_header_spec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_header_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method returns the data block header as a dictionary of the data</span>
<span class="sd">        block containing the spectrum whose index is provided.</span>

<span class="sd">        :param spec: The index of a spectrum.</span>
<span class="sd">        :type spec: int</span>

<span class="sd">        :return: The data block header with keywords and values.</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        .. code block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                # The index of the spectrum is 50</span>
<span class="sd">                spec = 50</span>
<span class="sd">                # Function to retrieve the size of the data block</span>
<span class="sd">                def db_size(spec):</span>
<span class="sd">                    db_header_dict = db_header_spec(spec)</span>
<span class="sd">                    return(db_header_dict.get(&#39;dbfilled&#39;, 0))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_sample_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_header</span><span class="p">(</span><span class="n">db_idx</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buffer.db_value">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.db_value">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Similar to the file header each data block has its own header. This</span>
<span class="sd">        method returns the value of the property specified by key in the</span>
<span class="sd">        specified data block. The first data block has the index 0.</span>

<span class="sd">        :param db_idx: The index of the data block.</span>
<span class="sd">        :type db_idx: int</span>
<span class="sd">        :param key: The string containing the key word.</span>
<span class="sd">        :type key: string</span>

<span class="sd">        :return: The data block value for the given key.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_header</span><span class="p">(</span><span class="n">db_idx</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span></div>


<div class="viewcode-block" id="Buffer.io_ports">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.io_ports">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">io_ports</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">byte</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">bit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated method!</span>
<span class="sd">        This method provides the state of the io ports at the time the</span>
<span class="sd">        dateblock (indicated by its number db_idx) is written. It does not</span>
<span class="sd">        provide information wether the state of any io port changes within the</span>
<span class="sd">        datablock. This method will be replaced by a method which analyses the</span>
<span class="sd">        data within the sub data block, which is part of the data block header</span>
<span class="sd">        and provides information regarding the state of the io ports at a</span>
<span class="sd">        higher accuracy.</span>

<span class="sd">        :param db_idx: Index of the data block</span>
<span class="sd">        :type db_idx: int</span>
<span class="sd">        :param byte: Number of io port socket [1, 2, 4]</span>
<span class="sd">        :type byte: int, optional</span>
<span class="sd">        :param bit: Number of bit [1, 2, 3, 4, 5, 6, 7, 8]</span>
<span class="sd">        :type bit: int, optional</span>

<span class="sd">        :raises ValueError: The bit argument requires the byte argument.</span>
<span class="sd">        :raises ValueError: The given byte has to be one out of [1, 2, 4].</span>
<span class="sd">        :raises ValueError: The given bit is out of range.</span>

<span class="sd">        :return: byte with the appropriate bits set as an int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">io_word</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_value</span><span class="p">(</span><span class="n">db_idx</span><span class="p">,</span> <span class="s1">&#39;io_ports&#39;</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xffffff</span>

        <span class="k">if</span> <span class="n">byte</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">bit</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The bit argument requires the byte argument&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">byte</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">io_word</span>

        <span class="k">if</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">io_word</span> <span class="o">=</span> <span class="p">(</span><span class="n">io_word</span> <span class="o">&gt;&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="k">elif</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">io_word</span> <span class="o">=</span> <span class="p">(</span><span class="n">io_word</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="k">elif</span> <span class="n">byte</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">io_word</span> <span class="o">=</span> <span class="p">(</span><span class="n">io_word</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The given byte has to be one out of [1, 2, 4]&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">io_word</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">bit</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;The given bit is out of range: </span><span class="si">{</span><span class="n">bit</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">io_word</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">bit</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="Buffer.io_ports_spec">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.io_ports_spec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">io_ports_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">byte</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bit</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated method!</span>
<span class="sd">        This method provides the state of the io ports at the time the</span>
<span class="sd">        dateblock (indicated by the spec number within the data block) is</span>
<span class="sd">        written. It does not provide information wether the state of any io</span>
<span class="sd">        port changes within the datablock. This method will be replaced by a</span>
<span class="sd">        method which analyses the data within the sub data block, which is</span>
<span class="sd">        part of the data block header and provides information regarding the</span>
<span class="sd">        state of the io ports at a higher accuracy.</span>

<span class="sd">        :param spec: Index of the spectrum</span>
<span class="sd">        :type spec: int</span>
<span class="sd">        :param byte: Number of io port socket [1, 2, 4]</span>
<span class="sd">        :type byte: int</span>
<span class="sd">        :param bit: Number of bit [1, 2, 3, 4, 5, 6, 7, 8]</span>
<span class="sd">        :type bit: int</span>

<span class="sd">        :raises ValueError: The bit argument requires the byte argument.</span>
<span class="sd">        :raises ValueError: The given byte has to be one out of [1, 2, 4].</span>
<span class="sd">        :raises ValueError: The given bit is out of range.</span>

<span class="sd">        :return: byte with the appropriate bits set as an int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">db_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_sample_count</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">io_ports_byte</span><span class="p">(</span><span class="n">db_idx</span><span class="p">,</span> <span class="n">byte</span><span class="p">,</span> <span class="n">bit</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buffer.file_size">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.file_size">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">file_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The file size of the buffer file. The value is not stored in the header</span>
<span class="sd">        but retrieved using the operating system.</span>

<span class="sd">        :return: file size in bytes</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_size</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_calc_spec_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;framedur&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">datamode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATAMODE</span><span class="o">.</span><span class="n">DATAMODE_FFT</span><span class="p">:</span>
            <span class="n">needed_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;fftovers&#39;</span><span class="p">,</span> <span class="s1">&#39;samplefr&#39;</span><span class="p">,</span> <span class="s1">&#39;comratio&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">needed_keys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Keys are missing to calculate the spec_duration. Missing keys: </span><span class="si">{</span><span class="p">[</span><span class="n">key</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">needed_keys</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">duration</span><span class="o">=</span><span class="p">(</span><span class="mf">1e9</span><span class="o">/</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;samplefr&#39;</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;fftovers&#39;</span><span class="p">]))</span><span class="o">/</span><span class="mi">1024</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;comratio&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;framedur&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">duration</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">datamode</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATAMODE</span><span class="o">.</span><span class="n">DATAMODE_SIGNAL</span><span class="p">:</span>
            <span class="n">needed_keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;samplefr&#39;</span><span class="p">,</span> <span class="s1">&#39;comratio&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">needed_keys</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Keys are missing to calculate the spec_duration. Missing keys: </span><span class="si">{</span><span class="p">[</span><span class="n">key</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">needed_keys</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

            <span class="n">sample_frq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;samplefr&#39;</span><span class="p">]</span>
            <span class="n">compression</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;comratio&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;framedur&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e9</span> <span class="o">/</span> <span class="n">sample_frq</span> <span class="o">*</span> <span class="n">compression</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_signalNormalizationFactor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">gain</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;_signalNormalizationFactor calculates a ref_energy factor to derive a normalized energy related to time, frequency and amplitude ranges</span>
<span class="sd">        of the buffer. A rectangular signal volume, which&#39;s base is the rectangle of one spectrums distance and one frequency band&#39;s width</span>
<span class="sd">        e.g. (100mV * 82�s * 1525Hz) = 0.012505 V. As the voltage is not squared, the result is close to the square-root of an energy.</span>

<span class="sd">        Each amplitude could reach a maximum of 1 Volt, the maximum ADC input voltage.</span>
<span class="sd">        Therefore we divide the amplitude with the maximum amplitude number to get it&#39;s portion in Volt.</span>
<span class="sd">        Then we multiply with the time and frequency square, as we assume the amplitude is constant over the complete square (our best guessing).</span>

<span class="sd">        When calculating energies of buffer ranges, we simply summarize the contained amplitudes.</span>
<span class="sd">        By multiplying the resulting sum with the ref_energy factor, we achieve the above described calculation of the signals volume.</span>

<span class="sd">        The resulting energy should be stable, even if compressing time and frequencies, using oversampling and different ADC ranges.</span>

<span class="sd">        sum of amplitudes,</span>
<span class="sd">        comparable even if sample rate, oversampling etc. is changing</span>
<span class="sd">        param gain,</span>
<span class="sd">        usually the amplitude ref is 1.0 equal 100% (eliminates the bit resolution of the buffer)</span>
<span class="sd">        could be enhanced with the amplification information of the amplifiers</span>

<span class="sd">        :param gain: can reflect changes of the amplification chain, energy is then related where the gain starts (sensor output e.g.), defaults to 1</span>
<span class="sd">        :type gain: float, optional</span>
<span class="sd">        :return: a factor to multiply with the sums of amplitudes in time-frequency-buffers</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">gain</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">max_amp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_amplitude_level</span> <span class="o">*</span> <span class="n">gain</span>
        <span class="c1">#16 bit=65535, gain=250 =&gt; maximum Amp=1V/250=0.004V ~ 4mV</span>
        <span class="k">if</span> <span class="n">max_amp</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_per_band</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span> <span class="o">/</span> <span class="mf">1e9</span> <span class="o">/</span> <span class="n">max_amp</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># normFactor = specDuration() / 1e9 / max_amp;</span>
                <span class="c1">#//@todo: calculation may be wrong, check it</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_amp</span><span class="o">=</span><span class="mi">2</span><span class="o">&lt;&lt;</span><span class="mi">16</span>
            <span class="n">max_amp</span><span class="o">*=</span><span class="n">gain</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frq_per_band</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span> <span class="o">/</span> <span class="mf">1e9</span> <span class="o">/</span> <span class="n">max_amp</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span>

<div class="viewcode-block" id="Buffer.block_infos">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.block_infos">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">block_infos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;preamp_gain&#39;</span><span class="p">,</span> <span class="s1">&#39;mux_port&#39;</span><span class="p">,</span> <span class="s1">&#39;measure_positions&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;outputs&#39;</span><span class="p">],</span> <span class="n">changes_only</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fast_jump</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;block_infos iterates through all memory blocks of a buffer file (typically one MB) and fetches the subdata information</span>
<span class="sd">        each memory block has one set of metadata but e.g. 65 subdata entries for raw files</span>
<span class="sd">        or more than 2000 entries for a 32 times compressed file,</span>
<span class="sd">        where each entry contains meta information about a small time frame (15 spectrums in raw fft files)</span>

<span class="sd">        :param columns: List of columns that should be in the result_array.</span>
<span class="sd">        You can define the order of the columns here.</span>
<span class="sd">        Possible column names are: [&#39;preamp_gain&#39;, &#39;mux_port&#39;, &#39;measure_positions&#39;, &#39;inputs&#39;, &#39;outputs&#39;, &#39;times&#39;, &#39;index&#39;, &#39;spectrums&#39;]</span>
<span class="sd">        :type columns: List[str]</span>
<span class="sd">        </span>
<span class="sd">        :param changes_only: Flag to enable a summarized output. If True the output does not contain all entries but only entries where the data columns changed.</span>
<span class="sd">        In the current implementation the memory consumption does not change here -&gt; in both cases the array is first completely built.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">        :type changes_only: bool</span>
<span class="sd">        </span>
<span class="sd">        :param fast_jump: If True the function uses seeking in the file instead of parsing every single datablock header.</span>
<span class="sd">        The offsets are investigated for the first datablock header and simply applied for all other datablock headers.</span>
<span class="sd">        Seeking is usually faster than parsing the datablock headers if they are not already in the cache.</span>
<span class="sd">        If the datablock headers are already cached this flag has no effect.</span>
<span class="sd">        Defaults to true.</span>
<span class="sd">        :type fast_jump: bool</span>

<span class="sd">        :return: header_infos, an array containing (spec_index), (index), (times), preamp_gain, mux_port, measure_position, 24bit input, 16bit output, (times), (index), (spec_index)</span>
<span class="sd">        :rtype: numpy array of int64, if times are included otherwise int32</span>
<span class="sd">        &quot;&quot;&quot;</span>


        <span class="n">data_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;preamp_gain&#39;</span><span class="p">,</span> <span class="s1">&#39;mux_port&#39;</span><span class="p">,</span> <span class="s1">&#39;measure_positions&#39;</span><span class="p">,</span> <span class="s1">&#39;inputs&#39;</span><span class="p">,</span> <span class="s1">&#39;outputs&#39;</span><span class="p">]</span>
        <span class="n">data_columns_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>  <span class="c1"># positions in subdat block</span>
        <span class="n">index_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;times&#39;</span><span class="p">,</span> <span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="s1">&#39;spectrums&#39;</span><span class="p">]</span>

        <span class="n">allowed_columns</span> <span class="o">=</span> <span class="n">data_columns</span> <span class="o">+</span> <span class="n">index_columns</span>

        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_columns</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is not a valid column name. Valid columns are: </span><span class="si">{</span><span class="n">allowed_columns</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">columns</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2"> is used multiple times. This is not allowed.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">changes_only</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span><span class="n">col</span> <span class="ow">in</span> <span class="n">index_columns</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;If you use the changes_only option you need to declare at least one index column. Otherwise the results would have no connection.&quot;</span><span class="p">)</span>

        <span class="c1">#interpreting the entries as int32 makes most sense</span>
        <span class="n">last_sample</span><span class="o">=</span><span class="mi">0</span>
        <span class="c1">#old header size was 10+32bit entries</span>
        <span class="n">ds_size</span><span class="o">=</span><span class="mi">10</span>
        <span class="n">mi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_header</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;begin_subdat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mi</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;begin_subdat keyword missing in datablock </span><span class="si">{</span><span class="mi">0</span><span class="si">}</span><span class="s1"> -&gt; caonnot read IO information&#39;</span><span class="p">)</span>

        <span class="n">subdat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">mi</span><span class="p">[</span><span class="s1">&#39;begin_subdat&#39;</span><span class="p">],</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1">#if it is of extended type, we expect a reasonable value here</span>
        <span class="n">mysize</span> <span class="o">=</span> <span class="n">subdat</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">.</span><span class="n">item</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">mysize</span><span class="o">==</span><span class="mi">80</span><span class="p">:</span><span class="c1">#the extended data length, additional sizes may occur</span>
            <span class="n">ds_size</span><span class="o">=</span><span class="mi">20</span> <span class="c1">#again the size in 32bit entries</span>

        <span class="n">entries_before</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">fast_jump</span><span class="p">:</span>
            <span class="n">db_start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_datablock_start_pos</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">db_start_pos</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
            <span class="n">db_header_content</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">)</span>
            <span class="n">start_mark</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;begin_subdat&#39;</span>
            <span class="n">end_mark</span> <span class="o">=</span> <span class="sa">b</span><span class="s1">&#39;end___subdat&#39;</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">subdat_offset_start</span> <span class="o">=</span> <span class="n">db_header_content</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start_mark</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">start_mark</span><span class="p">)</span>
                <span class="n">subdat_offset_end</span> <span class="o">=</span> <span class="n">db_header_content</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_mark</span><span class="p">)</span>
                <span class="n">subdat_length</span> <span class="o">=</span> <span class="n">subdat_offset_end</span> <span class="o">-</span> <span class="n">subdat_offset_start</span>
                <span class="n">subdat_readlen</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">subdat_length</span> <span class="o">/</span> <span class="n">subdat</span><span class="o">.</span><span class="n">itemsize</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The datablock header seems not to have a subdat block. Reading block info not possibe. </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">samples_per_entry</span> <span class="o">=</span> <span class="n">mi</span><span class="p">[</span><span class="s1">&#39;sd_rsize&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span>
        <span class="n">specs_per_entry</span> <span class="o">=</span> <span class="n">samples_per_entry</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span>
        <span class="n">entries_per_spec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">specs_per_entry</span>

        <span class="c1">#columns of interest:</span>
        <span class="c1">#pgain, mux_port, measure_position, 24bit input (inverted), 16bit output (inverted)</span>
        <span class="n">data_columns_src</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># column index in the buffers meta info array</span>
        <span class="n">data_columns_dest</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># column index in the target result_array</span>

        <span class="n">times_col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">index_col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">specs_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col</span> <span class="o">==</span> <span class="s1">&#39;times&#39;</span><span class="p">:</span>
                <span class="n">times_col</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">elif</span> <span class="n">col</span> <span class="o">==</span> <span class="s1">&#39;index&#39;</span><span class="p">:</span>
                <span class="n">index_col</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">elif</span> <span class="n">col</span> <span class="o">==</span> <span class="s1">&#39;spectrums&#39;</span><span class="p">:</span>
                <span class="n">specs_col</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="k">elif</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">data_columns</span><span class="p">:</span>
                <span class="n">data_columns_src</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data_columns_indices</span><span class="p">[</span><span class="n">data_columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col</span><span class="p">)])</span>
                <span class="n">data_columns_dest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">data_columns_dest</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">InvalidArgumentError</span><span class="p">(</span><span class="s1">&#39;You have to choose at least one data column!&#39;</span><span class="p">)</span>

        <span class="c1"># the indices of valid entries in the subdata block are calculated per datablock (checked in Analyzer4D DBgrabber::getSubDataPointer)</span>
        <span class="n">full_datablock_count</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_spec_count</span><span class="p">)</span>
        <span class="n">full_datablock_specs</span> <span class="o">=</span> <span class="n">full_datablock_count</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_spec_count</span>
        <span class="n">last_nonfull_datablock_specs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_spec_count</span>
        <span class="n">entry_count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">full_datablock_specs</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entries_per_spec</span><span class="p">))</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">last_nonfull_datablock_specs</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entries_per_spec</span><span class="p">))</span>
        
        <span class="c1"># 64 bit array if index columns are requested, otherwise 32 bit</span>
        <span class="n">arr_type</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span> <span class="k">if</span> <span class="nb">any</span><span class="p">((</span><span class="n">times_col</span><span class="p">,</span> <span class="n">index_col</span><span class="p">,</span> <span class="n">specs_col</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
        <span class="n">result_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">entry_count</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr_type</span><span class="p">)</span>  <span class="c1"># allocating the array!</span>

        <span class="c1"># loop through the datablocks</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_count</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fast_jump</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_headers</span><span class="p">:</span>  <span class="c1"># seeking is not faster than using cached datablock headers</span>
                <span class="n">db_start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_datablock_start_pos</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">db_start_pos</span> <span class="o">+</span> <span class="n">subdat_offset_start</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">SEEK_SET</span><span class="p">)</span>
                <span class="n">entries</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="n">subdat_readlen</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ds_size</span><span class="p">)</span>
                <span class="n">start_spec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_first_spec_of_datablock</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">end_spec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_first_spec_of_datablock</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_header</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;begin_subdat&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mi</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;begin_subdat keyword missing in datablock </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1"> -&gt; caonnot read IO information&#39;</span><span class="p">)</span>

                <span class="n">subdat</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">frombuffer</span><span class="p">(</span><span class="n">mi</span><span class="p">[</span><span class="s1">&#39;begin_subdat&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
                <span class="n">entries</span><span class="o">=</span><span class="n">subdat</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ds_size</span><span class="p">)</span>
                <span class="c1">#f_entries=np.empty((0,ds_size),dtype=np.int32)</span>

                <span class="c1">#print(&quot;mi[&#39;sd_rsize&#39;]&quot;, mi[&#39;sd_rsize&#39;])</span>
                <span class="n">samples_per_entry</span> <span class="o">=</span> <span class="n">mi</span><span class="p">[</span><span class="s1">&#39;sd_rsize&#39;</span><span class="p">]</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">bytes_per_sample</span>
                <span class="n">specs_per_entry</span> <span class="o">=</span> <span class="n">samples_per_entry</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span>
                <span class="n">entries_per_spec</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">specs_per_entry</span>

                <span class="n">start_spec</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">mi</span><span class="p">[</span><span class="s1">&#39;firstsam&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span><span class="p">)</span>
                <span class="c1">#the end_spec might differ from lastsamp for the last datablock: The real data might be shorter</span>
                <span class="n">end_spec</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">mi</span><span class="p">[</span><span class="s1">&#39;lastsamp&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span><span class="p">)</span>

            <span class="n">db_spec_count</span> <span class="o">=</span> <span class="n">end_spec</span> <span class="o">-</span> <span class="n">start_spec</span>

            <span class="c1"># the number of expected entries might be less than specs for low compressions, but never more than db_spec_count</span>
            <span class="n">entries_expected</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">db_spec_count</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entries_per_spec</span><span class="p">))</span>

            <span class="c1"># max(1, entries_per_spec) because for low compressions we get less than 1 entry per spec -&gt; take every entry</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">entries_expected</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entries_per_spec</span><span class="p">)</span>
            <span class="n">idxs</span> <span class="o">=</span> <span class="n">idxs</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

            <span class="c1">#filter the entries based on the calculated indexes</span>
            <span class="n">f_entries</span> <span class="o">=</span> <span class="n">entries</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>
            
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_entries</span><span class="p">)</span> <span class="o">==</span> <span class="n">entries_expected</span>  <span class="c1"># this must be equal - its critical to have a mismatch here!</span>

            <span class="c1"># writing columns_of_interest into the result_arr</span>
            <span class="n">result_arr</span><span class="p">[</span><span class="n">entries_before</span><span class="p">:</span><span class="n">entries_before</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">f_entries</span><span class="p">),</span> <span class="n">data_columns_dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">f_entries</span><span class="p">[:,</span> <span class="n">data_columns_src</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">times_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">start_time</span> <span class="o">=</span> <span class="n">start_spec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span>
                <span class="n">end_time</span> <span class="o">=</span> <span class="n">end_spec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span>
                <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">entries_expected</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>

                <span class="c1"># for strong compresssions we get exactly one (and never more than one) entries for each spectrum.</span>
                <span class="n">times</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span> <span class="o">/</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">entries_per_spec</span><span class="p">)</span>
                <span class="n">times</span> <span class="o">+=</span> <span class="n">start_time</span>

                <span class="n">times</span> <span class="o">=</span> <span class="n">times</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">result_arr</span><span class="p">[</span><span class="n">entries_before</span><span class="p">:</span><span class="n">entries_before</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">times</span><span class="p">),</span> <span class="n">times_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">times</span>

            <span class="k">if</span> <span class="n">index_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">entries_before</span><span class="p">,</span> <span class="n">entries_before</span> <span class="o">+</span> <span class="n">entries_expected</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">result_arr</span><span class="p">[</span><span class="n">entries_before</span><span class="p">:</span><span class="n">entries_before</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">index_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

            <span class="k">if</span> <span class="n">specs_col</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">entries_expected</span><span class="p">)</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">specs_per_entry</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="n">start_spec</span>
                <span class="n">result_arr</span><span class="p">[</span><span class="n">entries_before</span><span class="p">:</span><span class="n">entries_before</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">),</span> <span class="n">specs_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">index</span>

            <span class="n">entries_before</span> <span class="o">+=</span> <span class="n">entries_expected</span> <span class="c1">#len(f_value_list)</span>

        <span class="k">assert</span> <span class="n">entries_before</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_arr</span><span class="p">)</span>  <span class="c1"># If this fails we did something wrong when calculating the expected number of entries.</span>

        <span class="c1"># Some conversions to ensure readability of the values</span>
        <span class="k">if</span> <span class="s1">&#39;preamp_gain&#39;</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;preamp_gain&#39;</span><span class="p">)</span>
            <span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span>

        <span class="k">if</span> <span class="s1">&#39;inputs&#39;</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;inputs&#39;</span><span class="p">)</span>
            <span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]),</span><span class="mh">0xFFFFFF</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;outputs&#39;</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s1">&#39;outputs&#39;</span><span class="p">)</span>
            <span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bitwise_not</span><span class="p">(</span><span class="n">result_arr</span><span class="p">[:,</span> <span class="n">col</span><span class="p">]),</span><span class="mh">0xFFFF</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">changes_only</span><span class="p">:</span>
            <span class="n">changes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(((</span><span class="kc">True</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">result_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">data_columns_dest</span><span class="p">]</span> <span class="o">!=</span> <span class="n">result_arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">data_columns_dest</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">return</span> <span class="n">result_arr</span><span class="p">[</span><span class="n">changes_idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result_arr</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">header_hash</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A hash value for the buffer&#39;s header.</span>
<span class="sd">        The header of the buffer is almost unique for a buffer.</span>
<span class="sd">        A buffer should only differ in the length of the contained data.</span>

<span class="sd">        :return: The header&#39;s hash</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_hash</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">metainfo</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The buffer header properties as a dictionary.</span>

<span class="sd">        :return: The metainfo dictionary</span>
<span class="sd">        :rtype: dictionary</span>

<span class="sd">        .. code-block:: python</span>
<span class="sd">                :linenos:</span>

<span class="sd">                key = &#39;qassdata&#39;</span>
<span class="sd">                def keyword(key)</span>
<span class="sd">                    return buffer.metainfo[key]</span>

<span class="sd">                # The above example leads to a runtime error if the keyword is not a</span>
<span class="sd">                # key in the dictionary. It would be better to query this beforehand</span>
<span class="sd">                # and to provide a default value, thus:</span>

<span class="sd">                def keyword(key):</span>
<span class="sd">                    if key in buffer.metainfo.keys:</span>
<span class="sd">                        return buffer.metainfo[key]</span>
<span class="sd">                    else:</span>
<span class="sd">                        return default_value</span>

<span class="sd">                # or shorter:</span>

<span class="sd">                def keyword(key):</span>
<span class="sd">                    return buffer.metainfo.get(key, default_value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">filepath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the complete path to the file.</span>

<span class="sd">        :return: Path to the file</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__filepath</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">header_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each buffer file has a header. This property provides the size of the</span>
<span class="sd">        header in bytes (The normal value is 2000 bytes).</span>

<span class="sd">        :return: Size in bytes.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">project_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;proj__id&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The process number.</span>

<span class="sd">        :return: The process number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;proc_cnt&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">channel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The channel number used.</span>

<span class="sd">        :return: The channel number.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;dumpchan&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">streamno</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The index of a stream of an extra channel.</span>

<span class="sd">        Extra channels in the analyzer software can map multiple different data </span>
<span class="sd">        streams to the same channel of the software. This makes them only distuinguishable</span>
<span class="sd">        by this property.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;streamno&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datamode</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data mode is a constant which specifies what kind of data are in</span>
<span class="sd">        the buffer. The most important ones are DATAMODE_FFT and</span>
<span class="sd">        DATAMODE_SIGNAL. If you want to obtain the name of the constant, use</span>
<span class="sd">        `datamode.name`.</span>

<span class="sd">        :return: The data mode constant</span>
<span class="sd">        :rtype: enum class defined in :class:`.DATAMODE`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATAMODE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;datamode&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datakind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data kind constant is a constant which provides additional</span>
<span class="sd">        buffer specifications. A common value often is</span>
<span class="sd">        KIND_UNDEF. If you want to obtain the name of the constant, use</span>
<span class="sd">        `datakind.name`.</span>

<span class="sd">        :return: The data kind constant.</span>
<span class="sd">        :rtype: enum class defined in :class:`.DATAKIND`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATAKIND</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;datakind&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">datatype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The data type constant is a constant which specifies different</span>
<span class="sd">        compression and buffer types. The most important one being</span>
<span class="sd">        COMP_RAW. If you want to obtain the name of the constant, use</span>
<span class="sd">        `datatype.name`.</span>

<span class="sd">        :return: The data type constant.</span>
<span class="sd">        :rtype: enum class defined in :class:`.DATATYPE`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">DATATYPE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;datatype&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Posix timestamp of creation of the file</span>
<span class="sd">        in seconds since Thursday, January 1st 1970. Please note that the</span>
<span class="sd">        creation time and measure time might be different.</span>

<span class="sd">        :return: The timestamp as a number of seconds.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;proctime&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_date_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a timestamp of the creation of the file as a string.</span>

<span class="sd">        :return: The timestamp in the form &#39;yyyy-mm-dd hh:mm:ss&#39;</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s1">&#39;proctime&#39;</span><span class="p">]))</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_measure_timestamp</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Posix timestamp at measure start of the process in</span>
<span class="sd">        milliseconds. If epoctime (measure time) is not available due to an</span>
<span class="sd">        older buffer format, the creation time of the buffer is returned.</span>
<span class="sd">        Please note: The creation time may not be the same as epoc time.</span>
<span class="sd">        This is particularly true for compressed buffers which may be created</span>
<span class="sd">        much later!</span>

<span class="sd">        :return: The timestamp as a number in seconds.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epoctime&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;proctime&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">process_measure_time_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the time in ISO format at measure start of the process. If</span>
<span class="sd">        epoctime (measure time) is not available due to an older buffer</span>
<span class="sd">        format, the creation time of the buffer is returned. Please note:</span>
<span class="sd">        The creation time may not be the same as epoc time. This is</span>
<span class="sd">        particularly true for compressed buffers which may be created</span>
<span class="sd">        much later!</span>

<span class="sd">        :return: The timestamp in the form &#39;yyyy-mm-dd hh:mm:ss&#39;.</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
        <span class="n">tsms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;epoctime&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;proctime&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>

        <span class="n">datestr</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span>
            <span class="n">tsms</span> <span class="o">//</span> <span class="mi">1000</span><span class="p">)</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S.&#39;</span><span class="p">)</span>
        <span class="n">datestr</span> <span class="o">+=</span> <span class="nb">format</span><span class="p">(</span><span class="n">tsms</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">,</span> <span class="s2">&quot;03&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">datestr</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last_modification_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Posix timestamp of last modification of the file</span>
<span class="sd">        in seconds since Thursday, January 1st 1970.</span>

<span class="sd">        :return: The timestamp as a number in seconds.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lmodtime&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last_modification_date_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a timestamp of the last modification as a string.</span>

<span class="sd">        :return: The timestamp in the form &#39;yyyy-mm-dd hh:mm:ss&#39;</span>
<span class="sd">        :rtype: string</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">datetime</span><span class="o">.</span><span class="n">utcfromtimestamp</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;lmodtime&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;%Y-%m-</span><span class="si">%d</span><span class="s1"> %H:%M:%S&#39;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_header_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each data block has a header. This property provides the size of the</span>
<span class="sd">        data block header in bytes. The sizes of all data block headers are</span>
<span class="sd">        equal.</span>

<span class="sd">        :return: Size in bytes</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bytes_per_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Number of bytes per sample.</span>

<span class="sd">        :return: Number of bytes per sample (usually 2 bytes).</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of data blocks.</span>

<span class="sd">        :return: Number of data blocks.</span>
<span class="sd">        :rtype int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_count</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">full_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All but the last data block are usually completly filled. In order to</span>
<span class="sd">        calculate the number of those data blocks which are completely filled</span>
<span class="sd">        the header size of the file is substracted from the file size. This</span>
<span class="sd">        figure is divided by the sum of the data block header size and data</span>
<span class="sd">        block size and rounded down to the nearest integer.</span>

<span class="sd">        :return: Number of full data blocks.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">file_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the size of a completely filled data block in bytes.</span>

<span class="sd">        :return: Size of a completely filled data block.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_sample_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of samples in a completely filled data block.</span>
<span class="sd">        It is calculated by dividing the data block size by the number of</span>
<span class="sd">        bytes per sample.</span>

<span class="sd">        :return: Number of samples.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__db_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frq_bands</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Each spectrum has a maximum sample number of 512. This is the maximum</span>
<span class="sd">        number of frequency bands. This figure decreases with compression along</span>
<span class="sd">        the frequency axis. The corresponding key word in the metainfo</span>
<span class="sd">        dictionary &#39;s_p_fram&#39; (samples per frame).</span>

<span class="sd">        :return: Number of frequency bands.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">db_spec_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of spectra within a filled data block. It is calculated by</span>
<span class="sd">        dividing the number of samples in a data block by the number of</span>
<span class="sd">        frequency bands.</span>

<span class="sd">        :return: Number of spectra in a filled data block.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">db_sample_count</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compression_frq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property which returns the frequency compression factor.</span>

<span class="sd">        :return: Frequency compression factor.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;frqratio&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">compression_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property which returns the time compression factor.</span>

<span class="sd">        :return: Time compression factor.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;comratio&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">avg_time</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property which returns the moving average factor along the</span>
<span class="sd">        time axis.</span>

<span class="sd">        :return: Factor of the moving average.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;auxpara1&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">avg_frq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Property which returns the moving average factor along the</span>
<span class="sd">        frequency axis.</span>

<span class="sd">        :return: Factor of the moving average.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;auxpara2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spec_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The property returns the time for one spectrum in</span>
<span class="sd">        nanoseconds.</span>

<span class="sd">        :return: Time in nanoseconds.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;framedur&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frq_start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The property returns the lowest represented frequency.</span>

<span class="sd">        :return: Frequency in Hertz (Hz).</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;startfrq&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;startfrq&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="k">else</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frq_end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The property returns the highest represented frequency.</span>

<span class="sd">        :return: Frequency in Hertz (Hz).</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;end__frq&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;end__frq&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">frq_per_band</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frq_per_band</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The property returns the frequency range per band. The maximum number</span>
<span class="sd">        of bands is 512.</span>

<span class="sd">        :return: Frequency range in Hertz (Hz) for one band.</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;frqpband&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sample_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of samples in the buffer. It is calculated by subtracting</span>
<span class="sd">        the header size and the data block size times the number of datablocks</span>
<span class="sd">        from the file size. This figure is divided by the bytes per sample to</span>
<span class="sd">        obtain the number of samples. The number is cast to an int as the</span>
<span class="sd">        division usually results in a float due to an incompletely filled</span>
<span class="sd">        final data block.</span>

<span class="sd">        :return: Number of samples</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">without_header</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__header_size</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">((</span><span class="n">without_header</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_count</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">__db_header_size</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__bytes_per_sample</span><span class="p">)</span>

<div class="viewcode-block" id="Buffer.getRealSpecCount">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.getRealSpecCount">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">getRealSpecCount</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper function for the property spec_count.</span>
<span class="sd">        The number of spectra within a filled data block. It is calculated by</span>
<span class="sd">        dividing the number of samples in a data block by the number of</span>
<span class="sd">        frequency bands.</span>

<span class="sd">        :return: Number of spectra in a filled data block.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_count</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">spec_count</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The number of spectra in the buffer. It is calculated by dividing</span>
<span class="sd">        the number of samples by the number of frequency bands.</span>

<span class="sd">        :return: number of spectra</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_count</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">__frq_bands</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">last_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_spectrum</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">last_sample</span><span class="o">=</span><span class="mi">0</span>

            <span class="n">last_db</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_count</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">mi</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">db_header</span><span class="p">(</span><span class="n">last_db</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;lastsamp&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mi</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The datablock header does not contain a key &quot;lastsamp&quot;&#39;</span><span class="p">)</span>

            <span class="n">last_sample</span><span class="o">=</span><span class="n">mi</span><span class="p">[</span><span class="s1">&#39;lastsamp&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__last_spectrum</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">last_sample</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">frq_bands</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__last_spectrum</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">adc_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The type of analog/digital converter. The types are defined in class</span>
<span class="sd">        ADC_TYPE with the most important being ADC_16BIT and ADC_24BIT. If</span>
<span class="sd">        you want to obtain the name of the constant, use `adc_type.name`.</span>

<span class="sd">        :return: The ADCTYPE constant</span>
<span class="sd">        :rtype: enum class reference :class:`ADCTYPE`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ADCTYPE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;adc_type&quot;</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bit_resolution</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The bit resolution after the FFT. Caution: this is not the type of</span>
<span class="sd">        analog digital converter used. The usual value is 16. If no logarithm</span>
<span class="sd">        is applied to the data the value is 32.</span>

<span class="sd">        :return: The bit resolution.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;adbitres&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fft_log_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Base of the logarithm applied to the data. Please note that a 1 needs</span>
<span class="sd">        to be added to the value.</span>

<span class="sd">        :return: Base of the logarithm.</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;fftlogsh&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">max_amplitude_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        maximum possible amplitude of the buffer, relates to the buffer&#39;s dtype</span>
<span class="sd">        :rtype: int, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;max_ampl&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">refEnergy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        refEnergy provides a normalization factor for compressions.</span>
<span class="sd">        This makes sums of amplitudes of different compressions comparable to each other.</span>
<span class="sd">        See _signalNormalizationFactor for a detailed description.</span>

<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__norm_factor</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ref_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        alias for refEnergy()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">refEnergy</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">preamp_gain</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The preamplifier setting in the multiplexer tab of the Analyzer4D software.</span>

<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="p">[</span><span class="s2">&quot;pampgain&quot;</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">analyzer_version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The analyzer4D version as a dot separated string consisting of major.minor.micro.patch</span>
<span class="sd">        :rtype: str, None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;an4dvers&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">version</span> <span class="o">=</span> <span class="n">version</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
        <span class="n">version_tuple</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">version</span><span class="p">[</span><span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">version</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot;.&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">version_tuple</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">partnumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The string representation of the partnumber of the measurement.</span>
<span class="sd">        :rtype: str</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">asc_part_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__metainfo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;asc_part&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">asc_part_string</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">asc_part_string</span>
        <span class="k">return</span> <span class="n">asc_part_string</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\x00</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Buffer.spec_to_time_ns">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.spec_to_time_ns">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spec_to_time_ns</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spec</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method calculates the time since measurement start for a given</span>
<span class="sd">        index of a spectrum.</span>

<span class="sd">        :param spec: The index of a spectrum</span>
<span class="sd">        :type spec: int</span>

<span class="sd">        :return: time in nanoseconds</span>
<span class="sd">        :rtype: float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">spec</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span></div>


<div class="viewcode-block" id="Buffer.time_to_spec">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.time_to_spec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_to_spec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ns</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The method calculates the index of the nearest spectrum to the time</span>
<span class="sd">        given since the start of the measurement.</span>

<span class="sd">        :param time_ns: Time elapsed since measurement start in ns.</span>
<span class="sd">        :type time_ns: float</span>

<span class="sd">        :return: index of the spectrum</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">time_ns</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_duration</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buffer.delog">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.delog">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">delog</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">fft_log_shift</span><span class="p">,</span> <span class="n">ad_bit_resolution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to de-logarithmize a data array. Usually when data are measured</span>
<span class="sd">        with the Optimizer the data are logarithmized. The problem with</span>
<span class="sd">        logarithms is that adding them up constitutes a multiplication of the</span>
<span class="sd">        non logarithmized data. So in order to carry out calculations such as</span>
<span class="sd">        calculating sums etc. it is crucial to use de-logarithmized data.</span>

<span class="sd">        :param data_arr: Array with the logarithmized data.</span>
<span class="sd">        :type data_arr: numpy ndarray</span>
<span class="sd">        :param fft_log_shift: Base of the logarithm.</span>
<span class="sd">        :type fft_log_shift: int</span>
<span class="sd">        :param ad_bit_resolution: The bit resolution (usually 16).</span>
<span class="sd">        :type ad_bit_resolution: int</span>

<span class="sd">        :return: Array with de-logarithmized data.</span>
<span class="sd">        :rtype: numpy ndarray of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">fft_log_shift</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">ad_bit_resolution</span> <span class="k">if</span> <span class="n">ad_bit_resolution</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">16</span>
        <span class="n">bit_res_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">24</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>

        <span class="c1"># remember negative values:</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="n">data_arr</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">data_arr</span><span class="p">)</span>

        <span class="c1"># ensure data_arr to be a floating point array</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">shift_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">31</span><span class="p">][</span><span class="n">bit_res_idx</span><span class="p">]</span>
        <span class="n">max_amp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span>

        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">data_arr</span> <span class="o">*</span> <span class="p">(</span><span class="n">shift_offset</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span> <span class="o">/</span> <span class="n">max_amp</span> <span class="o">+</span> <span class="n">shift</span>

        <span class="n">data_arr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="n">data_arr</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span>
        <span class="n">data_arr</span><span class="p">[</span><span class="n">negative</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">data_arr</span></div>


<div class="viewcode-block" id="Buffer.log">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.Buffer.log">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">log</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">fft_log_shift</span><span class="p">,</span> <span class="n">ad_bit_resolution</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Method to logarithmize a data array. Usually when data are measured</span>
<span class="sd">        with the Optimizer the data are logarithmized. The problem with</span>
<span class="sd">        logarithms is that adding them up constitutes a multiplication of the</span>
<span class="sd">        non logarithmized data. So in order to carry out calculations such as</span>
<span class="sd">        calculating sums etc. it is crucial to use de-logarithmized data.</span>
<span class="sd">        Sometimes it is necessary to logarithmize data which were artificially</span>
<span class="sd">        created or measured without a logarithm.</span>

<span class="sd">        :param data_arr: Array with non-logarithmized data.</span>
<span class="sd">        :type data_arr: numpy ndarray of floats</span>
<span class="sd">        :param fft_log_shift: Base of the logarithm.</span>
<span class="sd">        :type fft_log_shift: int</span>
<span class="sd">        :param ad_bit_resolution: The bit resolution (usually 16).</span>
<span class="sd">        :type ad_bit_resolution: int</span>

<span class="sd">        :return: Array with logarithmized data.</span>
<span class="sd">        :rtype: numpy ndarray of floats</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="n">fft_log_shift</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">ad_bit_resolution</span> <span class="k">if</span> <span class="n">ad_bit_resolution</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">16</span>
        <span class="n">bit_res_idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">14</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">24</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>

        <span class="c1"># remember negative values:</span>
        <span class="n">negative</span> <span class="o">=</span> <span class="n">data_arr</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">data_arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">data_arr</span><span class="p">)</span>

        <span class="c1"># ensure data_arr to be a floating point array</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">data_arr</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="n">shift_offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">23</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">31</span><span class="p">][</span><span class="n">bit_res_idx</span><span class="p">]</span>
        <span class="n">max_amp</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bits</span>

        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">data_arr</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">))</span> <span class="o">-</span> <span class="n">shift</span>
        <span class="n">data_arr</span> <span class="o">=</span> <span class="n">data_arr</span> <span class="o">*</span> <span class="n">max_amp</span> <span class="o">/</span> <span class="p">(</span><span class="n">shift_offset</span> <span class="o">-</span> <span class="n">shift</span><span class="p">)</span>

        <span class="n">data_arr</span><span class="p">[</span><span class="n">negative</span><span class="p">]</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">return</span> <span class="n">data_arr</span></div>
</div>



<div class="viewcode-block" id="filter_buffers">
<a class="viewcode-back" href="../../../../buffer_parser.html#qass.tools.analyzer.buffer_parser.filter_buffers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">filter_buffers</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">filters</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is currently part of the buffer parser module but is</span>
<span class="sd">    likely to be moved into a repository with tools.</span>
<span class="sd">    This function takes a directory with buffer files and a dictionary with</span>
<span class="sd">    fiter criteria and returns a list of buffer objects from this</span>
<span class="sd">    dictionary which fulfill the filter criteria.</span>

<span class="sd">    :param directory: path to a directory with buffer files</span>
<span class="sd">    :type string</span>
<span class="sd">    :param filters: dictionary with filters</span>
<span class="sd">    :type dictionary</span>

<span class="sd">    :return: A list of buffer objects</span>
<span class="sd">    :rtype: list</span>

<span class="sd">    .. code-block:: python</span>
<span class="sd">            :linenos:</span>

<span class="sd">            from qass.tools.analyzer import buffer_parser as bp</span>
<span class="sd">            proc = range(1,100,1)</span>
<span class="sd">            # path contains the path to a directory containing buffer files</span>
<span class="sd">            buff = bp.filter_buffers(path, {&#39;wanted_process&#39;: proc , &#39;datamode&#39;: bp.Buffer.DATAMODE.DATAMODE_FFT})</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

    <span class="n">pattern</span> <span class="o">=</span> <span class="s1">&#39;*p*&#39;</span>
    <span class="k">if</span> <span class="s1">&#39;process&#39;</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
        <span class="n">pattern</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;process&#39;</span><span class="p">])</span>
    <span class="n">pattern</span> <span class="o">+=</span> <span class="s1">&#39;c&#39;</span>

    <span class="k">if</span> <span class="s1">&#39;channel&#39;</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">:</span>
        <span class="n">pattern</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">filters</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pattern</span> <span class="o">+=</span> <span class="s1">&#39;*&#39;</span>
    <span class="n">pattern</span> <span class="o">+=</span> <span class="s1">&#39;b*&#39;</span>

    <span class="n">buffers</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">Path</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span><span class="o">.</span><span class="n">rglob</span><span class="p">(</span><span class="n">pattern</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">Buffer</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="k">as</span> <span class="n">buff</span><span class="p">:</span>
                <span class="k">if</span> <span class="s1">&#39;process&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">buff</span><span class="o">.</span><span class="n">process</span> <span class="o">!=</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;process&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;unwanted_process&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">buff</span><span class="o">.</span><span class="n">process</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;unwanted_process&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;wanted_process&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">buff</span><span class="o">.</span><span class="n">process</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;wanted_process&#39;</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;channel&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;channel&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">channel</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;datamode&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;datamode&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">datamode</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;datakind&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;datakind&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">datakind</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;datatype&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;datatype&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">datatype</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;compression_time&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;compression_time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">compression_time</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;compression_frq&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;compression_frq&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">compression_frq</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;avg_time&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;avg_time&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">avg_time</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="s1">&#39;avg_frq&#39;</span> <span class="ow">in</span> <span class="n">filters</span> <span class="ow">and</span> <span class="n">filters</span><span class="p">[</span><span class="s1">&#39;avg_frq&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="n">buff</span><span class="o">.</span><span class="n">avg_frq</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">buffers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buff</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;filter_buffers could not parse: </span><span class="si">{</span><span class="n">file</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">return</span> <span class="n">buffers</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, QASS GmbH.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>